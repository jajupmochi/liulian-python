{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"LIULIAN","text":"<p>Liquid Intelligence and Unified Logic for Interactive Adaptive Networks</p> <p>\"Where Space and Time Converge in Intelligence\"</p> <p>Welcome to the LIULIAN documentation \u2014 a Research OS for spatiotemporal model experimentation.</p>"},{"location":"#what-is-liulian","title":"What is LIULIAN?","text":"<p>LIULIAN is a Python library that provides a unified, task-driven framework for training, evaluating, and performing inference with time-series, graph, and spatiotemporal models. It is designed for researchers who need reproducible experiment pipelines with minimal boilerplate.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>pip install uv\ngit clone https://github.com/jajupmochi/liulian-python.git\ncd liulian-python\nuv pip install -e \".[dev]\"\npython examples/quick_run.py\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Architecture \u2014 Design decisions and module overview</li> <li>Adapter Guide \u2014 How to write model adapters</li> <li>Manifest Specification \u2014 YAML dataset manifest format</li> <li>Contributing \u2014 How to contribute to liulian</li> </ul>"},{"location":"adapter_guide/","title":"Adapter Guide","text":"<p>This guide explains how to write a model adapter for LIULIAN. Adapters are the glue between LIULIAN's unified interface and specific model libraries.</p>"},{"location":"adapter_guide/#what-is-an-adapter","title":"What is an Adapter?","text":"<p>An adapter wraps an external model (e.g., Informer, N-BEATS, GNN) behind the <code>ExecutableModel</code> interface so that LIULIAN's runner can orchestrate it uniformly.</p>"},{"location":"adapter_guide/#adapter-contract-hard-rules","title":"Adapter Contract (Hard Rules)","text":""},{"location":"adapter_guide/#1-single-responsibility","title":"1. Single Responsibility","text":"<p>An adapter only wraps the model. It must NOT contain:</p> <ul> <li>\u274c Training loops</li> <li>\u274c Loss computation</li> <li>\u274c Metric calculation</li> <li>\u274c Data slicing or preprocessing</li> <li>\u274c Logging</li> </ul> <p>It SHOULD contain:</p> <ul> <li>\u2705 Load / initialise the model</li> <li>\u2705 Forward pass</li> <li>\u2705 Save / load checkpoints</li> <li>\u2705 Capability declaration</li> </ul>"},{"location":"adapter_guide/#2-file-size","title":"2. File Size","text":"<p>Recommend \u2264 200 lines of code per adapter file.</p>"},{"location":"adapter_guide/#3-dependency-isolation","title":"3. Dependency Isolation","text":"<p>All 3rd-party imports go through a <code>_vendor.py</code> file:</p> <pre><code># adapters/informer/_vendor.py\ntry:\n    from informer2020 import Informer\nexcept ImportError:\n    raise ImportError(\"Install informer2020: pip install informer2020\")\n</code></pre> <pre><code># adapters/informer/adapter.py\nfrom ._vendor import Informer\nfrom liulian.models.base import ExecutableModel\n</code></pre>"},{"location":"adapter_guide/#4-no-task-specific-logic","title":"4. No Task-Specific Logic","text":"<p>The adapter must be task-agnostic:</p> <pre><code># \u274c FORBIDDEN\ndef forward(self, batch):\n    if self.task.name == 'PredictionTask':\n        return self.predict(batch)\n\n# \u2705 CORRECT\ndef forward(self, batch):\n    return {'predictions': self.model(batch['X'])}\n</code></pre>"},{"location":"adapter_guide/#5-capability-metadata","title":"5. Capability Metadata","text":"<p>Every adapter must declare its capabilities:</p> <pre><code>def capabilities(self) -&gt; Dict[str, bool]:\n    return {\n        'deterministic': True,\n        'probabilistic': False,\n        'uncertainty': False,\n    }\n</code></pre>"},{"location":"adapter_guide/#6-required-test","title":"6. Required Test","text":"<p>Every adapter must have a unit test:</p> <pre><code># tests/adapters/test_my_adapter.py\n\ndef test_forward_shape():\n    model = MyAdapter()\n    model.configure(task, config={})\n    batch = {\"X\": np.random.randn(4, 36, 3).astype(np.float32)}\n    output = model.forward(batch)\n    assert \"predictions\" in output\n    assert output[\"predictions\"].shape == (4, 12, 3)\n</code></pre> <p>Requirements: - Runs on synthetic data only (no real datasets) - No GPU required - Completes in under 1 second</p>"},{"location":"adapter_guide/#example-dummymodel","title":"Example: DummyModel","text":"<p>See <code>liulian/adapters/dummy/adapter.py</code> for a complete reference implementation.</p>"},{"location":"adapter_guide/#file-structure","title":"File Structure","text":"<pre><code>liulian/adapters/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 dummy/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 adapter.py\n\u2514\u2500\u2500 informer/           # example: future adapter\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 _vendor.py       # isolate informer import here\n    \u2514\u2500\u2500 adapter.py\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>LIULIAN follows a task-driven experiment paradigm where the Task is a first-class citizen. Every experiment is defined by the combination of a Task, Dataset, Model (Adapter), and Runner.</p>"},{"location":"architecture/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    User[User / Config]\n    Task[Task Layer&lt;br/&gt;PredictionTask]\n    Data[Data Layer&lt;br/&gt;BaseDataset + Manifest]\n    Model[Model Layer&lt;br/&gt;ExecutableModel]\n    Adapter[Adapter Layer&lt;br/&gt;DummyModel, Informer...]\n    Runner[Runtime&lt;br/&gt;Experiment + StateMachine]\n    Optim[Optimizer&lt;br/&gt;RayOptimizer]\n    Logger[Logger&lt;br/&gt;WandB / LocalFile]\n    Artifacts[Artifacts&lt;br/&gt;spec.yaml, metrics, checkpoints]\n\n    User --&gt; Task\n    User --&gt; Data\n    Task --&gt; Runner\n    Data --&gt; Runner\n    Model --&gt; Adapter\n    Adapter --&gt; Runner\n    Runner --&gt; Optim\n    Runner --&gt; Logger\n    Runner --&gt; Artifacts</code></pre>"},{"location":"architecture/#architecture-decisions","title":"Architecture Decisions","text":"Decision Choice Rationale Dependency Management <code>uv</code> Fast, lock-file first, reproducible Configuration Env vars + YAML manifest Stateless for CI/cloud; manifest for data provenance Error Handling Exceptions Simple for MVP; validation errors only Logging stdlib <code>logging</code> + WandB WandB for remote; fallback to local JSON Testing Unit + integration; 60% min Smoke tests for adapters; e2e for runner"},{"location":"architecture/#module-responsibilities","title":"Module Responsibilities","text":""},{"location":"architecture/#task-layer-liuliantasks","title":"Task Layer (<code>liulian/tasks/</code>)","text":"<p>Defines what an experiment is trying to achieve \u2014 loss functions, evaluation metrics, and batch preparation. Tasks are task-agnostic to any specific model.</p>"},{"location":"architecture/#data-layer-liuliandata","title":"Data Layer (<code>liulian/data/</code>)","text":"<p>Manages dataset abstractions, YAML manifests for provenance, data splits, and topology specs for spatiotemporal graphs.</p>"},{"location":"architecture/#model-layer-liulianmodels","title":"Model Layer (<code>liulian/models/</code>)","text":"<p>Provides the <code>ExecutableModel</code> abstract interface that all adapters must implement \u2014 <code>configure()</code>, <code>forward()</code>, <code>save()</code>, <code>load()</code>, <code>capabilities()</code>.</p>"},{"location":"architecture/#adapter-layer-liulianadapters","title":"Adapter Layer (<code>liulian/adapters/</code>)","text":"<p>One adapter per external library. Each adapter wraps a specific model implementation (e.g., DummyModel, Informer) behind the <code>ExecutableModel</code> interface.</p> <p>Contract rules: - Single responsibility (model wrapper only \u2014 no training loop, loss, metrics) - \u2264 200 LOC per adapter - All 3rd-party imports via <code>_vendor.py</code> - Must declare <code>capabilities()</code> - Must have a unit test</p>"},{"location":"architecture/#runtime-layer-liulianruntime","title":"Runtime Layer (<code>liulian/runtime/</code>)","text":"<p>Orchestrates the experiment lifecycle through a state machine (INIT \u2192 TRAIN \u2192 EVAL \u2192 INFER \u2192 COMPLETED) with support for pause/resume and event callbacks.</p>"},{"location":"architecture/#optimizer-layer-liulianoptim","title":"Optimizer Layer (<code>liulian/optim/</code>)","text":"<p>Hyperparameter optimisation via Ray Tune with a fallback grid-sweep when Ray is not installed.</p>"},{"location":"architecture/#logger-layer-liulianloggers","title":"Logger Layer (<code>liulian/loggers/</code>)","text":"<p>Unified logging interface. Full WandB SDK integration with automatic fallback to local JSON logging when WandB is unavailable.</p>"},{"location":"architecture/#plugin-architecture","title":"Plugin Architecture","text":"<p>Domain-specific code (hydrology, traffic, etc.) lives in <code>plugins/</code>, not in the core package. Plugins inherit from core ABCs and are loaded as regular Python imports.</p>"},{"location":"contributing/","title":"Contributing to LIULIAN","text":"<p>Thank you for your interest in contributing to LIULIAN! This guide will help you get started.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code>git clone https://github.com/jajupmochi/liulian-python.git\ncd liulian-python\npip install uv\nuv pip install -e \".[dev,logging]\" --system\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use the following tools to maintain consistent code quality:</p> <ul> <li>black \u2014 Code formatting (line length 88)</li> <li>isort \u2014 Import sorting (profile: black)</li> <li>flake8 \u2014 Linting</li> <li>mypy \u2014 Static type checking</li> </ul> <p>Run all checks:</p> <pre><code>black --check liulian tests plugins\nisort --check liulian tests plugins\nflake8 liulian tests plugins\nmypy liulian\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code>pytest tests/ -v\npytest --cov=liulian --cov-report=term-missing tests/\n</code></pre> <p>All tests must pass in under 30 seconds. No GPU required.</p>"},{"location":"contributing/#writing-an-adapter","title":"Writing an Adapter","text":"<p>See the Adapter Guide for the full contract. Key rules:</p> <ol> <li>One adapter per external library</li> <li>Inherit from <code>ExecutableModel</code></li> <li>Keep adapter \u2264 200 LOC</li> <li>Use <code>_vendor.py</code> for 3rd-party imports</li> <li>Write a smoke test in <code>tests/adapters/</code></li> </ol>"},{"location":"contributing/#adding-a-domain-plugin","title":"Adding a Domain Plugin","text":"<ol> <li>Create <code>plugins/&lt;domain&gt;/</code> with <code>__init__.py</code> and adapter module</li> <li>Inherit from <code>BaseDataset</code> or <code>ExecutableModel</code></li> <li>Include a manifest YAML if applicable</li> <li>Add tests that run without the plugin's external dependencies</li> </ol>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/my-feature</code></li> <li>Write tests for any new functionality</li> <li>Ensure all tests pass and coverage \u2265 60%</li> <li>Run code formatters: <code>black . &amp;&amp; isort .</code></li> <li>Submit a pull request with a clear description</li> </ol>"},{"location":"contributing/#keeping-readmezhmd-in-sync","title":"Keeping README.zh.md in Sync","text":"<p>When updating <code>README.md</code>, please also update <code>README.zh.md</code> to keep the Chinese translation current. If you are not comfortable translating, note the change in your PR and a maintainer will handle it.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit Message Convention","text":"<p>Use conventional commits:</p> <pre><code>feat: add new adapter for ModelX\nfix: correct batch slicing in PredictionTask\ndocs: update architecture diagram\ntest: add smoke test for InformerAdapter\n</code></pre>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>Open a GitHub issue or start a discussion. We welcome all contributions, from bug reports to new adapters.</p>"},{"location":"manifest_spec/","title":"Manifest Specification","text":"<p>A manifest is a YAML file that describes a dataset's provenance, structure, and preprocessing steps. It is used by LIULIAN for data validation, reproducibility, and provenance tracking.</p>"},{"location":"manifest_spec/#required-fields","title":"Required Fields","text":"Field Type Description <code>name</code> string Unique dataset identifier <code>version</code> string Semantic version of the dataset <code>fields</code> list List of field descriptors (see below) <code>splits</code> dict Mapping of split names to date ranges or indices"},{"location":"manifest_spec/#optional-fields","title":"Optional Fields","text":"Field Type Description <code>source</code> string URL or DOI of the original data source <code>hash</code> string SHA-256 hash for integrity verification <code>description</code> string Human-readable dataset description <code>preprocessing</code> list Ordered list of preprocessing steps applied <code>topology</code> dict Graph / spatial topology metadata"},{"location":"manifest_spec/#field-descriptor","title":"Field Descriptor","text":"<p>Each entry in <code>fields</code> must have:</p> Key Type Required Description <code>name</code> string \u2705 Column / variable identifier <code>dtype</code> string \u2705 Numpy dtype (e.g. <code>float32</code>, <code>int64</code>) <code>unit</code> string \u274c Physical unit (e.g. <code>m3/s</code>, <code>degC</code>) <code>semantic_tags</code> list \u274c Free-form tags (e.g. <code>[target]</code>, <code>[feature]</code>)"},{"location":"manifest_spec/#topology-section","title":"Topology Section","text":"<p>For spatiotemporal datasets with graph structure:</p> <pre><code>topology:\n  node_ids: [\"S1\", \"S2\", \"S3\"]\n  edges:\n    - [\"S1\", \"S2\"]\n    - [\"S2\", \"S3\"]\n  coordinates:\n    S1: [46.95, 7.45]\n    S2: [46.80, 7.50]\n    S3: [46.65, 7.55]\n</code></pre>"},{"location":"manifest_spec/#full-example","title":"Full Example","text":"<pre><code>name: swissriver-v1\nsource: https://doi.org/10.5281/zenodo.example\nversion: \"1.0\"\nhash: \"sha256:abc123...\"\ndescription: &gt;\n  Swiss river network discharge dataset with hourly measurements.\n\npreprocessing:\n  - name: resample\n    params:\n      freq: \"1H\"\n  - name: fillna\n    params:\n      method: linear\n\nsplits:\n  train:\n    start: \"2010-01-01\"\n    end: \"2018-12-31\"\n  val:\n    start: \"2019-01-01\"\n    end: \"2019-12-31\"\n  test:\n    start: \"2020-01-01\"\n    end: \"2020-12-31\"\n\ntopology:\n  node_ids: [\"S1\", \"S2\", \"S3\", \"S4\", \"S5\"]\n  edges:\n    - [\"S1\", \"S2\"]\n    - [\"S2\", \"S3\"]\n    - [\"S3\", \"S4\"]\n    - [\"S4\", \"S5\"]\n\nfields:\n  - name: discharge\n    dtype: float32\n    unit: m3/s\n    semantic_tags: [target]\n  - name: precipitation\n    dtype: float32\n    unit: mm/h\n    semantic_tags: [feature]\n</code></pre>"},{"location":"manifest_spec/#validation","title":"Validation","text":"<p>Use <code>validate_manifest()</code> to check a manifest dict for errors:</p> <pre><code>from liulian.data.manifest import load_manifest, validate_manifest\n\nmanifest = load_manifest(\"manifests/swissriver_v1.yaml\")\nerrors = validate_manifest(manifest)\nif errors:\n    print(\"Manifest errors:\", errors)\n</code></pre>"}]}